Student Name: Kartikeya Sharma
Lab Section: 1 PM

(1.1) What is “stack smashing?”

Stack smashing is an intentional programmatic maneuver that corrupts the call stack.

(1.2) What is it that makes stack smashing possible?

Writing to a memory address outside of the range of the stack makes stack smashing possible.

(1.3) Log in to mips.bucknell.edu and examine the program example3.c. Do you think the local variable ret in the function function() means the same thing (ret) as you see in the Stack Smashing paper that is displayed on the stack? Why or why not?

I do think that the local variable ret in the function function() remains the same functionally as the ret in the Stack Smashing paper. Instead of adding 12 to the address of buffer[], example3.c adds 24 to that address. Then, example3.c, instead of adding 8, adds 16 to the return address. Similar to what was mentioned in the Stack Smashing paper, example3.c goes to the printf call after skipping the x assignment.

(1.4) Compile the file example3.c to an executable called example3. Open this file in gdb as indicated in the “Buffer Overflows” section of the paper and disassemble the main() function. If you open the example3.c file in your favorite text editor, you will see that its contents are very similar to the corresponding listing in the paper. Explain why the disassembled code looks so different from what you see in the paper.

The disassembled code looks so different because it is uniquely assembled rather than simply because the values we used are different. Analyzing the two assembled functions, one can say that the two compilers are different from one another because the instructions in either function are truly different. 

(1.5) To smash the stack, you need to know two key values, where is the end of the parameters and local variables on the stack, and how many bytes to skip after the function is returned. In our case, we would like the program to skip the instruction x = 4; in the main() function. In order to explain the two values in the function function(), you first need to understand what the code ret = (int*)(buffer1 + 24); and (*ret) += 16; do. Write your answers in prelab.txt.

"ret = (int*)(buffer1 + 24);" sets the value of the integer pointer ret to the sum of the address of buffer1[0] and 24. "(*ret) += 16;" adds 16 to the integer value pointed to by the integer pointer ret.

(1.6) The program structure explained in the Smashing the Stack paper differs from how our mips does things, though the concept is the same. In the paper, the local variables are arranged from high stack address value (deeper inside the stack) [(int *ret)] [buffer2][buffer1]. In our mips machine, the arrangement is different. Run gdb and disassemble the function main() and function(), save these output (numbered assembly code) into two text files for your reference. Then run the program in gdb and stop at the function function(). Examine the addresses of the local variables, ret, buffer1, and buffer2. Record these addresses and explain them in your prelab.txt.

buffer2: 0x7fffe534 (added 8 bytes)
buffer1: 0x7fffe52c (added 4 bytes)
ret: 0x7fffe528 (added 24 bytes)
sp: 0x7fffe510

(1.7) Now explain why the two values 24 and 16 are used in the function function().

The value 24 used in the function function() is used to set the value of ref equal to buffer2[0]. Also, the value 16 used in the function function() is used to set the value of buffer2[0] equal to 16; the value of 16 corresponds to the data link escape character from the ASCII character set. 

(1.8) Describe why when you run example3 on the mips machine the output is 7 rather than 4.

When example3 is compiled into assembly code on the mips machine, the register storing the value 7 mistakenly saves its value at the memory address where x is also being stored in memory. Moreover, the return address for the function was not correct. Upon termination of the function and its return to main, the program returned to the memory address with the printf line instead of the memory address with the line setting x to the value 4, as expected.
